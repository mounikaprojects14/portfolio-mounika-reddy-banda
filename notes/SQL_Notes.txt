Database: Is a Container to store data.(As in Tables like Rows & Columns)

RDBMS: Its an application that sits between Database and End User.
       As end user send some commands i.e., Insert or to Fetch data and that command understood by RDMS(Its interpreted by RDBMS). 
	   So RDBMS only can access DB but not End User. RDBMS only understands SQL.
	   Do not Store Data in it.

CONSTRAINTS:
------------
unique: will not have duplicates but will have NULL values
primary key: contains unique and will not have null values, and only 1 column exist as PK in a table when giving infront of column
			 But if we use constraint <<name>> primary key (col1, col2) we can use multiple cols.
foreign key: reference from pk table and unique key. and can have duplicate values.
		     Syntax: constraint <<name>> foreign key (col) references <<TBL_NAME>> (col)
			 For 1 col: references <<TBL_NAME>>(col)
check: It will only allow the values mentioned there i..e, check (Acc_type in ('Deposit', 'Saving'))
not null: will not allow NULL values.
default: if we dont give any values it will consider default mentioned value. 
		 Syntax: default 'PASS'

-->Truncate is much faster when compared to DELETE , and no need of any condition
   what it does internally its drops & recreates the table with same structure
-->DELETE deletes row 1-by-1 which is bit slow for large tables and needs condition while deleting rows
-->



Query:
------
SELECT DISTINCT TOP <COLS>,ROW_NUMBER() OVER()
	FROM <TABLE>
	JOIN <OTHER_TABLE>
		ON <CONDITIONS>
	WHERE <CONDITIONS>
	GROUP BY <COLS>
	HAVING <COLS>
	ORDER BY <COLS>
	
Order of Execution:
-------------------
1) FROM and JOIN
2) WHERE
3) GROUP BY
4) HAVING
5) ROW_NUMBER()
6) SELECT
7) DISTINCT
8) ORDER BY 
9) TOP / LIMIT

**Order of commands also matters we can never use having before where.
Because in the backend order of execution goes as below:
--------------------------------------------------------
Query Process Steps
--------------------
1. Getting Data (From, Join)
2. Row Filter (Where)
3. Grouping (Group by)
4. Group Filter (Having)
5. Return Expressions (Select)
6. Order & Paging (Order by & Limit / Offset)

PTR:
----
-> Where: will do filtering each individual row
-> Having: filtering performs on aggregation values
-> If we have Both WHERE and HAVING then 
	 1st priority : WHERE
	 2nd priority : HAVING
-> Natrural Join doesnt require any JOIn condition( i.e., ON) but if and 
   only if column name is same/matches then it works as self-join if not works as cross-join.

-> In SQL 2 NULL values will never be the same its a kind of No Value. NULL != NULL.
-> At least mean >= 
-> If there were couple of conditions then use OR operator.

				
To Trim Leading Zeros:
----------------------
with tbl AS (
  SELECT 0001023 as id UNION ALL
  SELECT 00120 as id UNION ALL
  SELECT 346 as id 
)

SELECT REGEXP_REPLACE(CAST(id AS STRING), '^0+', '') FROM tbl